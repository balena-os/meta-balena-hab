#!/bin/sh

# shellcheck disable=SC1091
. /usr/libexec/os-helpers-logging
. /usr/libexec/os-helpers-fs
. /usr/libexec/os-helpers-sb
. /usr/sbin/balena-config-defaults

BALENA_NONENC_BOOT_DEV=""

cryptsetup_enabled() {
    # Ensure that secure boot is enabled and device is locked
    if ! is_secured; then
        info "Won't attempt to decrypt drives because secure boot is not enabled"
        return 1
    fi

    # Flasher should not try to unlock the partitions
    if [ "$bootparam_flasher" = "true" ]; then
        # Booting flasher on a locked and encrypted device
        # Erase GPT for extra security
        if [ -L /dev/disk/by-label/${BALENA_NONENC_BOOT_LABEL} ]; then
            info "Flasher requested on locked device"
            _internal_dev=$(lsblk -nlo pkname,label | grep "${BALENA_NONENC_BOOT_LABEL}" | awk '{print $1}')
            erase_disk "${_internal_dev}"
        fi
        return 1
    fi

    return 0
}

cryptsetup_run() {
    # Die if anything fails here
    set -e

    boot_part_assert

    TMP_MOUNT_DIR=$(mktemp -d)
    _tmpkey="ikey"
    # Configured in the keyctl-caam source
    _keydir="/tmp/keys"
    BALENA_NONENC_BOOT_DEV=$(get_state_path_from_label "${BALENA_NONENC_BOOT_LABEL}")
    mount "$BALENA_NONENC_BOOT_DEV" "$TMP_MOUNT_DIR"

    # Make sure there is only one key
    if [ "$(find  "$TMP_MOUNT_DIR" -name "balena_*.enc" | wc -l)" -gt "1" ]; then
        fail "Multiple encryption keys found"
    fi

    for keyfile in "$TMP_MOUNT_DIR"/balena_*.enc; do
        if [ ! -e "${keyfile}" ]; then
            fail "No encryption key available"
        fi

        if ! caam-keygen import "${keyfile}" "${_tmpkey}"; then
            fail "Failed to import encryption key"
        fi
        _keyfile_base=$(basename "${keyfile}")
        _ksize=${_keyfile_base#balena_}
        _ksize=${_ksize%.enc}
    done

    if [ -f ${_keydir}/${_tmpkey} ]; then
        keyctl padd logon logkey: @u < ${_keydir}/${_tmpkey} > /dev/null
    else
        fail "Imported key not found"
    fi

    BOOT_DEVICE=$(lsblk -nlo pkname "${BALENA_NONENC_BOOT_DEV}")
    UNLOCKED=""
    for PART_DEV in $(lsblk -nlo kname,type "/dev/${BOOT_DEVICE}" | grep part | awk '{print $1}'); do
        PART_NAME=$(lsblk -nlo partlabel "/dev/${PART_DEV}")
        if [ "${PART_NAME}" = "${BALENA_NONENC_BOOT_LABEL}" ]; then
            continue
        fi
        case " ${DEFAULT_PARTITION_NAMES} " in
            *" ${PART_NAME#resin-} "*) ;;
            *" ${PART_NAME#balena-} "*) ;;
            *) fail "Trying to mount unknown partition label ${PART_NAME}";;
        esac
        _size=$(lsblk -nb -o NAME,SIZE "/dev/${PART_DEV}" | awk '{ print $2 }')
        _sector_size=$(lsblk -nlbo NAME,PHY-SEC,TYPE "/dev/${PART_DEV}" | awk '{print $2}')
        _sectors=$( expr "$_size" / ${_sector_size} )
        if ! dmsetup -v create "${PART_NAME}" --table "0 $_sectors crypt capi:tk(cbc(aes))-plain :$_ksize:logon:logkey: 0 /dev/${PART_DEV} 0 1 sector_size:${_sector_size}"; then
            fail "Failed to unlock encrypted partition ${PART_DEV}"
        fi
        UNLOCKED="${UNLOCKED} ${PART_NAME}"
    done

    # Wait for udev processing of each unlocked device
    for DM_NAME in ${UNLOCKED}; do
        wait4udev "/dev/mapper/${DM_NAME}"
    done

    # udev rules run after dmsetup but there is a race condition between
    # dm rules and the balena state rules that results in state links
    # not being created. Needs more investigation, but for the time being
    # re-run them here.
    udevadm trigger

    # Perform sanity checks after unlocking.
    dmcrypt_parts_assert $(echo "${UNLOCKED}" | wc -w)

    if umount "$TMP_MOUNT_DIR"; then
        rmdir "$TMP_MOUNT_DIR"
    fi

    # Revert the die on error
    set +e
}
